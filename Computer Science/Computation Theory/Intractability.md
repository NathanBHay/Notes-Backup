A problem is considered intractable if it is solvable in principle but the solutions require more time and space in practice.

# Hierarchy Theorems
The hierarchy theorems provide a method of proving that more languages run in higher [[Complexity Classes|space/time complexities]]  than lower, thus creating a hierarchy. 

## Space Hierarchy
The space hierarchy theorem proves the theorem for space complexity. The proof starts with the idea that a function $f:\mathcal{N}\to\mathcal{N}$ where $f(n)$ is at least $O(\log n)$ is called **space constructible** if the function maps the string $1^n$ to the binary representation $f(n)$ is computable in space $O(f(n))$. This means a TM can be constructed that always halts with the binary representation of the function in $f(n)$ time steps. All commonly occurring functions are space constructible. For example a $n^2$ machine can obtain a binary by counting numbers of 1s and output $n^2$ by using any method of multiplying itself. 

The **space hierarchy theorem** expands this definition to say that for any space constructible function $f:\mathcal{N}\to\mathcal{N}$, a language $A$ exists that is decidable function $O(f(n))$ space but not in $o(f(n))$ space. This can be proved through designing a decider $D$ that decides for $A$. The decided runs in $O(f(n))$ space, and guarantees that $A is different from languages decidable in $o(f(n))$. Language $A$ lacks a non-algorithmic definition. To ensure it in $o(f(n))$ the decider $D$ must implement the [[Set Theory#Cantor's Diagonal Argument|diagonalization argument]] to prove the insolvability of an [[Decidability|acceptance problem]]. If $M$ is a TM that decides a language in $o(f(n))$ space $D$ is different from $M$ in at least one place, the place corresponding to a description of $M$ itself. Therefore, $D$ decides a language by computing the space constructability and marking off the amount of space used, if later stages of the algorithm use more reject. If the input is not of form $\langle M\rangle10^*$ reject. Simulate $M$ on the word while counting number of steps. If $M$ accepts rejects, else accept. If you run $D$ on the input $\langle M\rangle10^{n_0}$ then you find the input is longer than $n_0$ so the decider doesn't halt therefore not deciding for $A$.

Therefore, for any two functions $f_1, f_2:\mathcal{N}\to\mathcal{N}$ where $f_1(n)$ is $o(f_2(n))$, and $f_2$ is space constructible, then $\text{SPACE}(f_1(n))\subsetneq\text{SPACE}(f_2(n))$. This allows you to separate complexity. For example two natural numbers can be seen to prove $\text{SPACE}(n^{c_1})\subseteq\text{SPACE}(n^{c_2})$. Therefore, $\text{NL}\subsetneq\text{PSPACE}$, and $\text{PSPACE}\subsetneq\text{EXPSPACE}$. The latter is particularly important as it proves there exists decidable problems that are intractable. 

## Time Hierarchy
The time hierarchy theorem proves the theorem for time complexity. A **time constructable** function is a function $t:\mathcal{N}\to\mathcal{N}$ that is at least $O(n\log n)$ that maps a string $1^n$ to the binary representation of $t(n)$ in $O(t(n))$ computable time. 

The **time hierarchy theorem** states that for any time constructible function a language $A$ exists that is decidable in $O(t(n))$ time but not in $o(t(n)/\log t(n))$. This is a looser definition that for space complexity. This proof is similar to space hierarchy except that it the proof concerns the cost of simulating $M$ while at the same time counting the number of steps. This allows proofs that $\text{TIME}(t_1(n))\subsetneq\text{TIME}(t_2(n))$ and therefore $\text{P}\subsetneq\text{EXPTIME}$.

# Relativization
The relativization proof is a method of giving evidence against the possibility of solving the P versus NP by using a proof of diagonalization. This proof modifies [[Turing Machine|Turing machines]] to be able to solve certain information for free. This is done through creating a black box called an oracle. A language $A$ has an **oracle** that is capable of reporting whether the string $w$ is a member of $A$. An oracle TM $M^A$ is a modified TM that has the capability o querying an oracle for $A$. Whenever $M^A$ writes to the **oracle tape** it is informed of whether $A$ is a member in a single computation step. Let $\text{P}^A$ be the class of languages decidable with a polynomial time oracle that uses A. And let $\text{NP}^A$ be in non-polynomial time.

This allows us to see that for oracles $A$ and $B$ we can find that $\text{P}^A\neq\text{NP}^A$ and $\text{P}^B=\text{NP}^B$. This means that if you could prove $P$ and $NP$ by diagonalization we could prove different relative oracles as well. But as this breaks the second statement, this can't be proven. The relativization proof tells us that $P$ versus $NP$ must be analyzed rather than solved with simulated computations.

# Circuit Complexity
Circuit complexity is an analysis of the complexity of [[Propositional Logic|logical circuits]]. These circuits are a collection of gates with inputs and outputs. A **circuit family** $C$ is an infinite list of circuits $(C_0,C_1,C_2,\dots)$ where $C_n$ has $n$ input variables. A language decides $A$ over $\{0,1\}$ if every string $w\in A$ is found as $C_n(w)=1$, where $n$ is the length of $w$. A circuit's **size** is the number of gates that it contains. A circuit is **size minimal** if it is in its minimum size form. The **size complexity** of the family is the function of $f(n)$. The **depth** of a circuit is the length of the longest oath from an input variable to an output gate. **Depth minimal**, and **depth complexity** are assigned similarly. A **circuit's complexity** of a language is the size complexity of the minimal circuit family for that language. A **circuit's depth complexity** is depth rather than size. This language allows us to give an approach to proving $\text{P}\neq\text{NP}$ where it is shown that some languages in NP have more than polynomial circuit complexity.

Circuit complexity also proves the Cook-Levin theorem by creating the language of Circuit-Sat which is the language of satisfiable Boolean circuits. This problem is [[Complexity Classes#NP-Completeness|NP-complete]].
