Amortized analysis is a type of  that averages the time required to perform a sequence of [[Data Structures|data structure]] operations over all operations performed. This means despite certain actions being expensive they can be seen as cheaper if done a small amount of times. It differs from average analysis as probability isn't involved as amortized analysis guarantees the average performance of each operation in the worst case. There are a variety of methods of finding amortized complexity. These are aggregate, accounting, and potential.

## Aggregate Method
Aggregate analysis is a method of finding the amortized complexity. It states that for all $n$, a sequence of $n$ operations takes worst-case time $T(n)$ in total. This means the worst, average, and amortized cost is found as $T(n)/n$. Intuitively this means the aggregate method counts up the complexity of each operation to find the amortized cost. For example, a stack with a pop all action finds that the push, and pop actions have $O(1)$ complexity. While the multi-pop is found as $O(n-1)$, where $n$ is the amount of push operations. Thus. by dividing all these actions by the time complexity it takes to pop it finds the amortized complexity for pop all is $O(1)$. Another example of this is incrementing a binary counter. Upon each increment the amount of flips depends on the amount of changed digits. This finds a growth of $O(2n)$ flips as the amount of operations grow by $n+\frac n 2 + \frac n 4 + \cdots + \frac{n}{2^{\log n}}$.

## Accounting Method
Accounting method is another method of amortized analysis where operations are given a value to represent their amortized cost. When an operations amortized cost exceeds its actual cost it assigns the difference as credit. Credit can help pay for layer operations whose amortized cost is less than their actual cost. The choice of operation cost must be considered carefully with the usual rule to make low cost operations charged more than their actual cost, and high cost operations less. For example a binary counter can be assigned a bit flip cost of 2. This means in reality to flip $00$ to $01$ it will cost 1 but store 1 as credit. As a result when flipping $01$ to $10$ this credit is used to flip the other bit. This finds a total cost of $O(n)$ to flip.

## Potential Method
Potential method of amortized analysis represents the prepaid work as potential which can be released for future operations. This follows, given $n$ operations with the initial structure $D_0$. For each $i=1,2,\dots,n$ let $c_i$ be the actual cost of the $i$th operation and $D_i$ be the data structure that results after applying the operation. A potential function $\Phi$ maps the data structure $D_i$ to a real number which is the potential associated with the structure. The amortized cost $\hat c_i$ of the $i$th operation with respect to the potential function is therefore defined by:
$$\hat c_i=c_i+\Phi(D_i)-\Phi(D_{i-1})$$
The amortized cost of each operation is therefore its actual cost plus the change in potential during the operation. Thus: 
$$\sum^n_{i=1}\hat c_i=\sum^n_{i=1}c_i+\Phi(D_n)-\Phi(D_0)$$
Intuitively this states that if the potential difference is positive then the amortized cost represents an overcharge and the potential of the data structure increases. If the potential difference is negative then the amortized cost represents an undercharge and the decrease in the potential pays for the actual cost of the operation.
